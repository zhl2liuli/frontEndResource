### js权威指南
- 正则表定义
## 直接量
- 1.字母和数字
- 2.非字母匹配（"\"）
  [元字符](http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp)
## 字符类：

```text
  [adfgh], [a-z], [a-zA-Z0-9],
  [^wsad] ==> 否定字符类
  . ==> 除换行符和其他行终止符之外的任意字符
  \w === [a-zA-Z0-9]
  \W === [^a-zA-Z0-9]
  \s ==> 空白符
  \S ==> 非空白符
  \d === [0-9]
  \D === [^0-9]
  [\b] ==> 退格
```
## 量词
  {n, m} ==> n~m次
  {n,} ==> 至少n次
  ? === {0,1}
  + === {1,}
  * === {0,}
  上面都是贪婪匹配，非贪婪匹配可在后面加上? ==> {n, m}?, +?
  注意：正则的匹配总是会寻找字符串的第一个可能匹配的位置 ==> /a+b/和/a+?b/匹配"aaab"返回值都是"aaab"
## 选择，分组，引用
  | ==> 选择（从左向右）
  () ==>组合或定义子模式
  \1, \2, ... ==> 引用前面的子表达式（不能在字符类中使用引用）
  (?:) ==> 此分组不被引用
## 锚
  ^ ==> 开始位置
  $ ==> 结束为止
  \b ==> 单词边界
  \B ==> 非单词边界
  (?=p) ==> 匹配之后的字符与p匹配，但返回字符不包括p
  (?!p) ==> 匹配之后的字符不与p匹配。
## 修饰符
  i ==> 不区分大小写
  g ==> 全局匹配
  m ==> 多行匹配

- 正则方法
  1.search() ==> str.search(RegExp) ==> 返回第一个与之匹配的位置，没有返回-1，不支持全局匹配。
  2.replace() ==> str.replace(RegExp, replaceStr) ==> 可以全局g匹配
    replaceStr可以用$n引用RegExp中的分组，切其可以是函数。
  3.macth() ==> str.match(RegExp) ==> 返回数组：
     当设置全局匹配g返回的数组是所有匹配的结果；
     当不是全局匹配返回的数组第一个为所匹配的str，剩下的是分组匹配的字符串。
  4.split() ==> str.split(RegExp)

- RegExp对象
  RegExp()当第一个参数传入字符串时\ 必须转义成\\。
## 属性
  只读：
  source 
  global
  ignoreCase
  multiline
  读写：
  lastIndex ==> 匹配模式为g时，下一次检索位置。
## 方法
  1.exec() ==> RegExp.exec(str) ==> 
    不论是否匹配全局，返回数组一样。返回值和match不全局匹配一样，但多了两个属性index（匹配的位置）和input（正在检索的字符串）；
    但当有g是，他会把当前正则对象的lastIndex属性设置为紧挨着匹配后的位置。当这个表达式再次调用则从lastIndex开始。没检索到则lastIndex设置为0。
  2.test() ==> RegExp.test(str) 
  注意：用一个正则对象对多个在字符串进行检索，要手动设置lastIndex为0
